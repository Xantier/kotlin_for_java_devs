<!doctype html>
<html lang="en" xmlns="http://www.w3.org/1999/html">

<head>
    <meta charset="utf-8">

    <title>Kotlin For Java Developers</title>

    <meta name="description" content="Introduction to Kotlin for Java Devs">
    <meta name="author" content="Jussi Hallila">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/night.css" id="theme">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement('link');
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName('head')[0].appendChild(link);
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<body>

<div class="reveal">

    <!-- Any section element inside of this container is displayed as a slide -->
    <section class="slides">
        <section>
            <h1>Kotlin</h1>
            <h3>Saviour of the Java platform</h3>
            <small><a href="http://jussi.hallila.com">Jussi Hallila</a> / <a
                    href="http://twitter.com/Xantier">@Xantier</a>
            </small>
            <aside class="notes">
                Programming for 8 years, 6 in Dublin. From PHP to Java to... Javascript, Falling in Love with Spring.
                Hating Java. Loving the ecosystem. Loving the tooling. Tried Spring, Play, Ratpack, Vaadin, Android.
                Always seem to be coming back to Spring.
                Love Jetbrains. My wife bought me my first IntelliJ license and renews it yearly on my birthday. That
                subscription is the glue that keeps our marriage together.
                On Kotlin for a year. Journey started with frustration to old codebase, fuck java7.
            </aside>
        </section>

        <section>
            <section>
                <h1>Selling points</h1>
            </section>
            <section>
                <h2>Beautiful Syntax</h2>
                Succinct yet expressive
                <pre><code class="kotlin hljs" data-trim contenteditable>// file: Beaut.kt
data class Lunch(val bread: String, val topping: String)
val yumyum = Lunch("Toast", "Avocado")
fun main(args: Array&lt;String>){
    val buyHouse: (Lunch) -> Unit = {
        val (_, topping) = it
        when(topping){
            "Avocado" -> println("Not a chance")
            else -> println("Hmmm... still probably no")
        }
    }
    buyHouse(yumyum)
}

// Not a chance
</code></pre>
                <aside class="notes">
                    all these things make the lang pretty and terse. data classes, val, inlined constructors,
                    first class functions and function types, destructuring, pretty lambdas and...
                </aside>
            </section>
            <section>
                <h2>Superior Type Inference</h2>
                Just enough
                <pre><code class="kotlin hljs" data-noescape data-trim contenteditable>
var str: String = "Text"
val str = "String"
fun sideEffects() {
    println("Returning Unit -> no need for type")
}
fun expressiveFunc() = "Return type String, as is known"
fun explicit(): String {
    return "Making the return type explicit"
}
</code></pre>
                <aside class="notes">
                    some basic syntax. Val is defining a value, var is defining a variable. Vals are "immutable", in
                    reality readonly values, var can be reassigned.
                    Types are after because then we can infer. functions can omit "void" words, in this lang Unit,
                    functions can be expressions and then the type can be inferred from the full thing
                    also if the type needs to be displayed, then it is similarly placed after the function with a colon
                </aside>
            </section>
            <section>
                <h2>Full Java Interoperability</h2>
                <pre><code class="kotlin hljs" data-noescape data-trim contenteditable>public class Interop {
    public static void main(String[] args) {
        final Lunch lunch = BeautKt.getYumyum();
        System.out.println("I had "
        + lunch.getTopping()
        + " on "
        + lunch.getBread()
        + " for lunch.");
    }
}
// I had avocado on toast for lunch.</code></pre>
            </section>
            <section>
                <h2>Null Safety</h2>
                <pre><code class="java hljs fragment" data-noescape data-trim contenteditable>
public String doSomething(String arg1, String arg2, ...){
	if (arg1 == null) {
 		throw new IllegalArgumentException("arg1 == null");
	}
	if (arg2 == null) {
 		throw new IllegalArgumentException("arg1 == null");
	}
	// Etc
	// Finally do something
}
					</code><code class="java hljs fragment" data-noescape data-trim contenteditable>
java.lang.nullPointerException
	at com.something.doSomething(Something.java:42)
	at com.someframework.doThatThing(ThingDoer.java:13)
	at org.application.service.letsHopeThisWorks(HopeBuildsSoftware.java:666)
	...
	...s
					</code></pre>
                <aside class="notes">
                    Change braces to be shitty
                    Casting, is, as, not null, elvis, question mark, EXCLAMATION!!
                </aside>
            </section>
            <section>
                <h2>Null Safety</h2>
                <p>
                <pre><code class="kotlin hljs" data-noescape data-trim contenteditable>class TopShelf(val drinks: List&lt;String><span
                        class="fragment highlight-blue">?</span>)
<span class="fragment">
fun main(args: Array&lt;String>){
    val monday = TopShelf(null)
    println(monday.drinks<span class="fragment highlight-red">.</span>get(0))
}
</span><span class="fragment">/*
* Error Kotlin: Only safe (?.) or non-null asserted (!!.)
* calls are allowed on a nullable receiver of type List&lt;String>?
*/
</span>
                </code></pre>
                <pre><code class="kotlin hljs fragment" data-noescape data-trim
                           contenteditable>println(monday.drinks<span
                        class="fragment highlight-green">?.</span>get(0)) // This is grand
<span class="fragment">// null</span>
                </code></pre>
                <aside class="notes">
                    we have a class topshelf that contains our drinks. Come monday and first day of work this week,
                    naturally there is a bit of a, hmm this is a Finnish idiom, your mouth is snapping, (snap snap)
                    meaning the
                    sound you mouth makes when it's dry. It's not only the irish who are prone to take a pint or two...
                    anyways, come monday and when we try to reach a bottle of midleton from the topshelf, it is empty.
                    Weekend is gone
                    and restocking trip is not done yet, so our drink list is null.
                    Kotlin knows this and prevents us from reaching to that shelf. Java devs can try it and maybe injure
                    their arm or something when reaching for the empty shelf

                </aside>
            </section>
            <section>
                <h2>Tooling</h2>
                <ul>
                    <li>Jetbrains native citizen - Kotlin &lt;3 IntelliJ</li>
                    <li>Native in Android Studio as well</li>
                    <li>Build processes click in place with Maven & Gradle (and Ant)</li>
                    <li>Plugins to Eclipse (official), Sublime, Atom, Vim</li>
                    <li>Magical intellisense out of the box</li>
                </ul>
                <aside class="notes">
                    haven't touched Android studio. My wife takes care that I don't have to because she keeps feeding me
                    IntelliJ
                    The community has decided to save their fingers and not build an emacs plugin
                    IntelliJ driven development. Idris is fun. ctrl+space, ctrl+space, ctrl+space
                </aside>
            </section>
        </section>
        <section>
            <section>
                <h1>High level laws of Kotlin</h1>
                <aside class="notes">
                    Let's jump through these laws quickly and then continue onto some code examples.
                    I wasn't brave enough to do live coding, so all the code is on the slides. Hopefully it is
                    comprehensible
                </aside>
            </section>
            <section>
                <h2>Finality</h2>
                <ul>
                    <li>Classes final by default</li>
                    <li>vals final by default</li>
                    <li>open keyword to make classes extendable</li>
                </ul>
                <aside class="notes">
                    see bytecode from beaut
                    Something like spring for open. Makes classes essentially immutable since not extendable and props
                    are final
                </aside>
            </section>
            <section>
                <h2>Organization</h2>
                <p>
                <ul>
                    <li>1 file, multiple definitions</li>
                    <li>top-level, essentially global, functions & values</li>
                    <li>Decompiled to a class by filename and static vars/funcs</li>
                </ul>
                </p>
                <aside class="notes">
                    Create file, create functions, create vars.
                    Decompile, see java code
                </aside>
            </section>
            <section>
                <h2>Visibility</h2>
                <ul>
                    <li>Everything is public by default</li>
                    <li>Modifiers: private, internal, protected</li>
                </ul>
                <aside class="notes">
                    public, because immutable
                    and public visibility modifier
                    internal, module scoped
                    no package protected visibility, everything should be in modules instead
                </aside>
            </section>
        </section>
        <section>
            <section>
                <h1>Classes, Interfaces, Objects and Basic syntax</h1>
            </section>
            <section>
                <h2>Classes, Interfaces and Objects</h2>
                <pre><code class="fragment kotlin hljs" data-noescape>class EmptyClass
<span class="fragment">interface MarkerInterface</span>
<span class="fragment">class WithConstructor(val value: String): MarkerInterface</span>
<span class="fragment">class WithMembers(val value: String) {
    fun doFun() = "Fun!"
}</span>
<span class="fragment">object Singleton {
    val staticity = "Not Quite, but close"
}</span>
<span class="fragment">class Companied {
    companion object {
        val truly = "Static, truly static"
    }
} <span class="fragment">// Companied.truly</span></span></code></pre>
                <aside class="notes">
                    No need for parens or braces
                    constructor is built in, val = read only, var read-write
                    objects are singletons by default and be called as such.
                    companion objects are holders for static stuff within a class. replacements for private static final
                    daa-daa-daa
                    also const keyword is there for values if you want to have a truly constant value (aka, those snake
                    cased uppercase sentences)
                </aside>
            </section>
            <section>
                <h2>Classes, Interfaces and Objects</h2>
                <pre><code class="fragment kotlin hljs" data-noescape>object initialized{
    val thing: String
    init {
        thing = "Hello"
    }
}
<span class="fragment">class LateBloomer{
    lateinit var thang: String
    fun doTheInit(str: String){
        thang = str
    }
    <span class="fragment">@Autowired
    lateinit var thong: String</span>
    <span class="fragment">@Inject
    lateinit var gString: String</span>
}</span>
</code></pre>
                <aside class="notes">Few keywords we can introduce here.
                    init, lateinit.
                    without lateinit types would be nullable. Kotlin is at war against null
                </aside>

            </section>
            <section>
                <h2>Data Classes</h2>
                <pre><code class="fragment kotlin hljs" data-noescape>
data class Covfefe(val first: String, val second: String)
</code></pre>
                <span class="fragment">data class -> toString, equals, hashCode, copy</span>
                <pre><code class="fragment kotlin hljs" data-noescape>
val (america, finland) = Covfefe("America", "Finland")
</code></pre>
            </section>
            <section>
                <h2>Data Classes</h2>
                <pre><code class="fragment kotlin hljs" data-noescape>public final class Covfefe {
   @NotNull
   private final String first;
   @NotNull
   private final String second;

   @NotNull
   public final String getFirst() {
      return this.first;
   }

   @NotNull
   public final String getSecond() {
      return this.second;
   }

   public Covfefe(@NotNull String first, @NotNull String second) {
      Intrinsics.checkParameterIsNotNull(first, "first");
      Intrinsics.checkParameterIsNotNull(second, "second");
      super();
      this.first = first;
      this.second = second;
   }

   @NotNull
   public final String component1() {
      return this.first;
   }

   @NotNull
   public final String component2() {
      return this.second;
   }

   @NotNull
   public final Covfefe copy(@NotNull String first, @NotNull String second) {
      Intrinsics.checkParameterIsNotNull(first, "first");
      Intrinsics.checkParameterIsNotNull(second, "second");
      return new Covfefe(first, second);
   }

   public String toString() {
      return "Covfefe(first=" + this.first + ", second=" + this.second + ")";
   }

   public int hashCode() {
      return (this.first != null?this.first.hashCode():0) * 31 + (this.second != null?this.second.hashCode():0);
   }

   public boolean equals(Object var1) {
      if(this != var1) {
         if(var1 instanceof Covfefe) {
            Covfefe var2 = (Covfefe)var1;
            if(Intrinsics.areEqual(this.first, var2.first) && Intrinsics.areEqual(this.second, var2.second)) {
               return true;
            }
         }

         return false;
      } else {
         return true;
      }
   }
}

</code></pre>
            </section>
            <section>
                <h2>Sealed Classes</h2>
                <pre><code class="fragment kotlin hljs" data-noescape>sealed class NextBigThing
<span class="fragment">data class PiperChat(val pakistaniDenzel: String): NextBigThing()
data class PiedPiper(val weissmanScore: String): NextBigThing()</span>
</code></pre>
            </section>
            <section>
                <h2>When matching</h2>
                <pre><code class="fragment kotlin hljs" data-noescape>val matchable: NextBigThing = fetchBigThing()
<span class="fragment">when(matchable){
  is PiperChat -> println("Creepy Videochat")
  is PiedPiper -> println("New Internet")
  <span class="fragment highlight-red"><span class="fragment fade-out">else -> println("nope")</span></span>
}</span>
</code></pre>
                <aside class="notes">
                    is --> instanceof
                    but surprise! no need for else
                </aside>
            </section>
            <section>
                <h2>when, if, try = expressions</h2>
                <pre><code class="fragment kotlin hljs" data-noescape contenteditable>val drivingForce = when(matchable){
    is PiperChat -> matchable.pakistaniDenzel
    is PiedPiper -> matchable.weissmanScore
}
<span class="fragment">val carDoors = if(matchable is PiperChat) {
    "--(ツ)--"
} else {
    "¯\\_(ツ)_/¯"
}</span>
<span class="fragment">val payingRent = try {
    askJinYang()
} catch (ex: InsultException){
    // Swallow ex
    "aFat and aPoor"
}</span>
</code></pre>
            </section>
        </section>
        <section>
            <section>
                <h1>Functions</h1>
            </section>
            <section>
                <h2>Fun, Fun, Fun</h2>
                <p>
                <pre><code class="fragment kotlin hljs" data-noescape>val funType: <span class="fragment highlight-blue">(<span class="fragment highlight-red">num: </span>Int) -> Int</span> = {<span
                        class="fragment highlight-red">num -> </span>num * num}
<span class="fragment">val funType2: (Int) -> Int = {it * it}</span>
<span class="fragment">val funfunType: (Int, (Int) -> Int) -> Int = { num, func ->
    func(num) * func(num)
}</span><span class="fragment">
<span class="fragment highlight-blue">inline</span> fun &lt;S, <span class="fragment highlight-blue">reified</span> T> inliner(other: S, typed: T) {
    if (other is T) {
        print("Same Types")
    }
}</span>            </code></pre>
                <aside class="notes">
                    Don't worry, I'll run out of Silicon Valley references soon enough

                    Top level functions lead to extinction of static util method up to a point, there is also another
                    reason in the lang that enhances that effect
                    If there is a need to namespace or scope these things, you can use objects. But it's not really
                    needed.
                    Far abstracted functions might be a good idea to keep in these spot, though there are better places
                    to dump those in if type safety

                    you'll rarely define functions to vals, because, well why would you? makes a good demo for func
                    types
                </aside>
                </p>
            </section>
            <section>
                <h2>Infix and operator functions</h2>
                <p>
                <pre><code class="fragment kotlin hljs" data-noescape contenteditable>data class PiperChat(val pakistaniDenzel: String): NextBigThing() {
    <span class="fragment highlight-blue">operator</span> fun plus(internet: PiedPiper) = when(pakistaniDenzel){
        "fired" -> internet
        else -> this
    }
}<span class="fragment">
sealed class NextBigThing {
    <span class="fragment highlight-blue">infix</span> fun until(num: Int) = when(this) {
        is PiedPiper -> weissmanScore.toInt() - num
        is PiperChat -> 2 - num
    }
}</span><span class="fragment">
val games = PiedPiper("23")
var eye = 2
val <span class="fragment highlight-blue">`fun`</span> = PiperChat("Dinesh")</span>
<span class="fragment">val scoreOrEyeCount: Int = `fun` <span class="fragment highlight-blue">+</span> games <span
        class="fragment highlight-blue">until</span> --eye</span>
            </code></pre>
                <aside class="notes">
                    I was lying, there is endless fun in Silicon Valley
                    fun backticked, because keyword
                    operator keyword, is bound to a class and needs to take one argument, in this case the internet
                    infix keyword, same rules.
                </aside>
                </p>
            </section>
            <section>
                <h2>Extension functions</h2>
                <p>
                <ul>
                    <li>Adding functionality to existing classes</li>
                    <li>Removes the need for util classes completely</li>
                    <li>Resolved statically</li>
                    <li>Can't be used to override existing funs</li>
                </ul>
                </p>
                <aside class="notes">
                    misleading statically, they need to be invoked to an instance of a class, not class itself
                    if you want a proper static function, you can use companion objects
                </aside>
            </section>
        </section>
        <section>
            <section>
                <h1>Lambdas</h1>

            </section>
            <section>
                <h2>Lambdas</h2>
                <p>
                <pre><code class="fragment kotlin hljs" data-noescape>val lamdba = { arg<span class="fragment highlight-blue">: Int</span> ->
    arg * arg
}<span class="fragment">
/* val lambda = */ {<span class="fragment fade-out">it: Int -> </span>it * it }</span>
<span class="fragment">fun macbook(func: () -> Unit) = func()</span><span class="fragment">
macbook({ println("trash") })
</span><span class="fragment">macbook{ println("trash") }</span>
<span class="fragment">fun isTrashbook(make: Int, func: (Int) -> Boolean): Boolean =
    func(make)</span>
<span class="fragment">val isTrash = isTrashbook(2016) {
    it == 2016
}</span>            </code></pre>
                </p>
                <aside class="notes">
                    or in this case lamd-ba
                    Can access closure and modify closure vars
                    What make lambdas very good are these braces and how they are handled. Kotlin guys have thought this
                    out excellently
                    Just like your teeth, proper placement of these braces will make for a beautiful outline

                    first use case for these is probably in -->
                </aside>

            </section>
        </section>
        <section>
            <section>
                <h1>Collections & Extensions</h1>
            </section>
            <section>
                <h2>Collections</h2>
                <ul>
                    <li>Wrappers around Java collections</li>
                    <li>Mutable and Immutable versions</li>
                    <li>Sequences for lazy evaluated collections</li>
                    <li>Usual suspects:
                        <ul>
                            <li>Lists</li>
                            <li>Arrays</li>
                            <li>Sets</li>
                            <li>Maps</li>
                        </ul>
                    </li>
                </ul>
                </p>
            </section>
            <section>
                <h2>Collection Extensions</h2>
                <ul>
                    <li>Maps, Filters, Reducers, FlatMaps, Zippers</li>
                    <li>Addition and Subtraction copies of immutables</li>
                    <li>Predicates to check collection state</li>
                    <li>Takes, Drops, Finds, First/Last for accessing elements</li>
                    <li>etc.</li>
                </ul>
                </p>
            </section>
            <aside class="notes">

                From these we get a good bridge back to extension function, all collection extensions are, as the name
                says,
                done as extension functions to those wrapped collection classes
            </aside>

        </section>
        <section>
            <section>
                <h1>Extension functions</h1>
            </section>
            <section>
                <h2>Extensions</h2>
                <p>
                <ul>
                    <li>Possible to have a nullable receiver with ?</li>
                    <li>Also extension properties</li>
                    <li>Can be declared as members of a class</li>
                    <li>Can be used as a function argument</li>
                </ul>
                </p>
                <aside class="notes">
                    extension props only with getter/setter, no backing fields
                </aside>
            </section>
            <section>
                <h2>Extension examples</h2>
                <p>
                <pre><code class="kotlin hljs" data-noescape><span class="fragment">fun String.uberized() = this + ", bro"</span>
<span class="fragment">println("what's up".uberized())</span><span class="fragment"> // what's up, bro </span>

<span class="fragment">fun String<span class="fragment highlight-blue">?</span>.uberized() = (this <span
        class="fragment highlight-blue">?:</span> "No way") + ", mo"</span>
<span class="fragment">val str: String? = null
println(str.uberized())</span> <span class="fragment">// No way, mo</span>

<span class="fragment">val String.fine: String
    get() = "a dumpster fire"
fun String.`is`(situation: String) = this + "is $fine"</span><span class="fragment">
println("uber".`is`("".fine))</span><span class="fragment"> // uber is a dumpster fire</span></code></pre>
                </p>
                <aside class="notes">
                    Decompile first and second
                    For humour purposes we omit the usage situation

                    there is also inlining that can be done for few purposes
                </aside>
            </section>
            <section>
                <h2>Lambdas with receivers</h2>
                <p><span class="fragment">From stdLib</span>
                <pre><code class="kotlin hljs" data-noescape><span class="fragment">fun &lt;T, R> T.let(f: (T) -> R): R = f(this)
</span><span class="fragment">// nullableVar?.let { print(it.someValue) }</span><span class="fragment">
fun &lt;T> T.apply(f: T.() -> Unit): T { f(); return this }
</span><span class="fragment">// javaBean.apply { this.beanField1 = "First field" } </span><span class="fragment">
fun &lt;T, R> with(receiver: T, f: T.() -> R): R = receiver.f()
</span><span class="fragment">// with(imperativo) { dothis() doThat() }</span><span class="fragment">
fun &lt;T, R> T.run(f: T.() -> R): R = f()
</span><span class="fragment">// "str".run { this + "otherStr" } </span>
<span class="fragment">fun &lt;T> T.also(block: (T) -> Unit): T { block(this); return this }</span>
<span class="fragment">// javaBean.also { it.beanField2 = "Second Field" }  </span>
</code></pre>
                </p>
                <aside class="notes">
                    let: can be used to scope. eg. getDBconn, let do stuff, and return done stuff, conn is gone after
                    that
                    apply: this is the object that it's called on, receiver
                    with: similar to apply, but returns the result from within lambda
                    run: simple way to scope your vars and return from it using enclosing as this
                    also: similar to apply, but the enclosing class is this and it is the receiver
                </aside>
            </section>
            <section data-transition="zoom-in">
                <h2>Typesafe DSLs</h2>
                <p>Scaffolding
                <pre><code class="kotlin hljs fragment" data-noescape>data class Pizza(val name: String,
    var toppings: List&lt;Topping><span class="fragment highlight-blue"> = emptyList()</span>,
    val price: Int<span class="fragment highlight-blue"> = 0</span>)

interface Topping {
    val name: String
    val unitPrice: Int
}

abstract class BaseTopping(<span class="fragment highlight-blue">override</span> val name: String,
    <span class="fragment highlight-blue">override</span> val unitPrice: Int = 0): Topping {
    var amount: Int = 0
    operator fun plus(that: Topping): List&lt;Topping> =
        listOf(this, that)
}
            </code></pre>
                </p>
                <aside class="notes">
                    Came from groovy world. But now typesafe. Android users might be familiar with anko
                    Gradle kotlin script is done like this.
                    Let's set up a scenario
                    Note default values for price and toppings
                    abstract members -> function and val + var
                    data class can have member function as well, this is written outside just for fun
                </aside>
            </section>
            <section data-transition="zoom-in">
                <h2>Typesafe DSLs</h2>
                <p>Scaffolding
                <pre><code class="kotlin hljs" data-noescape>class Cheese: <span class="fragment highlight-blue">BaseTopping("Cheese")</span> {
    override val unitPrice: Int
        <span class="fragment highlight-blue">get() = 3</span>
}<span class="fragment">
class Ananas: Topping("Ananas"){
    override val unitPrice = 4
}
class Anchovy: Topping("Anchovy"){
    override val unitPrice = 6
}</span>            </code></pre>
                </p>
                <aside class="notes">
                    with get and setter, or without, doesn't matter
                </aside>
            </section>
            <section data-transition="zoom-in fade-out">
                <h2>Typesafe DSLs</h2>
                <p>Construction
                <pre><code class="kotlin hljs fragment" data-noescape>fun Pizza.`with`(topper: () -> List&lt;Topping>): Pizza =
    apply { toppings = topper() }
<span class="fragment">
infix fun Int.of(topping: BaseTopping): BaseTopping =
    topping.also { it.amount = this }</span>
                <span class="fragment">
fun order(name: String, <span class="fragment highlight-blue">hoef: Pizza.() -> Pizza</span>) =
    Pizza(name).hoef()
</span></code></pre>
                </p>
                <aside class="notes">
                    with get and setter, or without, doesn't matter
                </aside>
            </section>
            <section data-transition="zoom-in fade-out">
                <h2>Typesafe DSLs</h2>
                <p>
                <pre><code class="kotlin hljs fragment" data-noescape>fun main(args: Array&lt;String>) {
    order("Kotlinante") { <span class="fragment">// (name, Pizza.() -> Pizza) -> Pizza</span>
        `with` { <span class="fragment">// this == our Kotlinante pizza</span>
            (3 of Cheese()) +
            (2 of Anchovy()) +
            (2 of Ananas())
        <span class="fragment">// listOf(Cheese(amount=3), Anchovy(amt=2), Ananas(amt=2))</span>
        }
    }
}<span class="fragment">
// Pizza(name=Kotlinante, toppings=[Cheese@279f2327,
// Anchovy@2ff4acd0, Ananas@54bedef2], price=0)</span></code></pre>
                </p>
                <aside class="notes">
                    Any italians in the audience, is the name italian sounding enough?
                </aside>
            </section>
        </section>
        <section>
            <section>
                <h1>Delegates</h1>
            </section>
            <section>
                <h2>Delegates</h2>
                <p>
                <ul>
                    <li>Built-in delegation pattern</li>
                    <li>Can be used to implement interfaces</li>
                    <li>Property getting and setting by delegation</li>
                </ul>
                </p>
            </section>
            <section>
                <h2>Standard library helpers</h2>
                <pre><code class="hljs kotlin fragment" data-noescape>class Sloth {
    val timeToSleep: Boolean by lazy {
        println("Always")
        true
    }
}
<span class="fragment">class NosyNeighbour {
    var shoppingTrip: Groceries by observable(Groceries()) {
        _, previousGroceries: Groceries, newGroceries: Groceries ->
            println("""Again he bought more craft beer.
    I believe he is a beer connoisseur, not an alcoholic.""")
    }  <span class="fragment">// property: KProperty<*></span>
}
</span><span class="fragment">class Wifey {
    var shoppingTrip: Groceries by vetoable(Groceries()) {
        _, previousGroceries: Groceries, newGroceries: Groceries ->
        !newGroceries.containsBeer()
    }
}
</span></code> </pre>
                <aside class="notes">
                    lazy from Delegates class, read only. saves return into backing field, returns directly from there
                    in the future
                    underscore is _: KProperty<*>
                    observable, needs an argument to itm the argument is the initial value, aka identity, write only
                    vetoable, needs an argument to it, write only, returns true and does things based that

                    mention by map, delegate. Can be used to take in map to a constructor and then assign to properties
                    based on their names
                    Can be local as well
                </aside>
            </section>
            <section>
                <h2>Manual delegation</h2>
                <p>Properties</p>
                <pre><code class="hljs kotlin fragment" data-noescape>data class Pizza(val name: String,
    var toppings: List&lt;Topping> = emptyList()) {
        <span class="fragment highlight-blue">val price: Int by PriceCalculator()</span>
        override fun toString() =
            "name=$name, price=$price, toppings=$toppings"
}
<span class="fragment">class PriceCalculator : ReadOnlyProperty&lt;Pizza, Int> {
    override fun getValue(thisRef: Pizza, property: KProperty&lt;*>) =
        thisRef.toppings.fold(0) { acc, it ->
            acc + it.unitPrice
        }
}</span><span class="fragment">
// Pizza(name=Kotlinante, toppings=[Cheese@3caeaf62,
// Anchovy@e6ea0c6, Ananas@6a38e57f], price=13)</span>                </code> </pre>
                <aside class="notes">
                    need to ovveride tostring because price is not initialized in constructor
                    remember, there was no price in the "topping" interface, just unitprice
                    cheese =3, ananas=4, anchovy=6, no amounts yet though.
                    Interface, needs to implemented in a class, no lambdas here
                </aside>
            </section>
            <section>
                <h2>Manual delegation</h2>
                <p>Classes</p>
                <pre><code class="hljs kotlin fragment" data-noescape>interface Topping {
    val name: String
    val unitPrice: Int
}
<span class="fragment">abstract class BaseTopping(<span
        class="fragment highlight-blue">val priceProvider: Topping</span>)
    : Topping <span class="fragment highlight-blue">by priceProvider</span> {
    var amount: Int = 0
    operator fun plus(that: Topping): List&lt;Topping> =
        listOf(this, that)
    override fun toString() =
        "{name=$name, price=$unitPrice, amount=$amount}"
}</span>                </code> </pre>
                <aside class="notes">
                    cheese =3, ananas=4, anchovy=6, no amounts yet though.
                    Also this is not class delegation
                </aside>
            </section>
            <section>
                <h2>Class level delegation</h2>
                <pre><code class="hljs kotlin fragment" data-noescape>class PriceAndNameProvider(override val name: String,
    override val unitPrice: Int): Topping
<span class="fragment">class Cheese : BaseTopping(PriceAndNameProvider("Cheese", 3))
class Ananas : BaseTopping(PriceAndNameProvider("Ananas", 4))
class Anchovy : BaseTopping(PriceAndNameProvider("Anchovy", 6))</span>

<span class="fragment">val BaseTopping.price: Int
    get() = unitPrice * amount</span>
<span class="fragment">// { acc, it ->
//    acc + (it as BaseTopping).price
// }</span></code> </pre>
                <aside class="notes">
                    cheese =3, ananas=4, anchovy=6, no amounts yet though.
                    Also this is not class delegation
                </aside>
            </section>
            <section data-transition="zoom-in fade-out">
                <h2>Typesafe delegated higher order lambdas with receivers DSL</h2>
                <p>
                <pre><code class="kotlin hljs fragment" data-noescape>fun main(args: Array&lt;String>) {
    order("Kotlinante") {
        `with` {
            (3 of Cheese()) +
            (2 of Anchovy()) +
            (2 of Ananas())
        }
    }
}<span class="fragment">
// name=Kotlinante, price=29, toppings=
//   [{name=Cheese, price=3, amount=3},
//    {name=Anchovy, price=6, amount=2},
//    {name=Ananas, price=4, amount=2}]
</span></code></pre>
                </p>
                <aside class="notes">
                    How do you really do this?
                    You try to write a good DSL call and then ram down Ctrl+space and hope IntelliJ fills things out for
                    you.
                </aside>
            </section>
        </section>
        <section>
            <h2>Kotlin 1.1</h2>
            <p>
            <ul>
                <li>Type aliases</li>
                <li>Coroutines</li>
                <li>Javascript support</li>
            </ul>
            </p>
            <aside class="notes">
                released in march. Haven't had time to touch any of those yet.
                Like said I'm not a full time Kotlin dev, probably not even a good one...
                though i've been said that I'm the best Kotlin dev in the world...
                by my wife... who is a goldsmith and knows fuck all about programming, I'd take that with a grain of
                salt
                Aanyways
            </aside>
        </section>

        <section>
            <section>
                <h2>How Do I sell this beauty to the management?</h2>
                <p>
                <ul>
                    <li>Java interoperability</li>
                    <li>Safety</li>
                    <li>Cheap investment</li>
                    <li>Easeness</li>
                </ul>
                </p>
            </section>
            <section>
                <h2>Java interoperability</h2>
                <p>All already familiar frameworks work out of the box. <br/>Many frameworks!</p>
            </section>
            <section>
                <h2>Safety</h2>
                <p>The Compiler helps us a lot more than in Java.<br/>Safe like a wall!</p>
                <aside class="notes">
                    Have you ever been in a situation where a list of commit on a project grows and grows while you add
                    null checks. Maybe the database gives out some incorrect data, maybe you're just tired and want to
                    go the fuck home. Anyways, not with Kotlin. It'll be one commit because the compiler will keep
                    moaning.
                    Also better type system keeps the code more succinct and with that devs are more willing to make the
                    sacrifices
                    to actually create type safe structures with interfaces and classes.
                    Proper type aliases would have given this an extra boost but can't get everythign
                </aside>
            </section>
            <section>
                <h2>Cheap investment</h2>
                <p>It just works. <br>There is no need to rewrite anything, existing codebase can remain untouched and
                    adding it to a project is <i>literally</i> a three click operation.<br/>Cheap!</p>
            </section>
            <section>
                <h2>Easeness</h2>
                <p>If you know Java, you'll learn Kotlin in few days, guaranteed.<br/>So easy!
            </section>
            <section>
                <h2>It is more fun</h2>
                <p>Once you go Kotlin,</p>
                <p class="fragment"> your fun will be Dublin </p>
                <aside class="notes">
                    I'm so sorry about this. Trying to come up with a good pun on this took maybe 80% of the preparation
                    time to this presentation. I don't even know how to explain that so it would make sense. If you have
                    any suggestions, please let me know.
                </aside>
            </section>
        </section>
        <section>
            <h1>TY</h1>
        </section>
    </section>
</div>

</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>

  // More info https://github.com/hakimel/reveal.js#configuration
  Reveal.initialize({
    controls: true,
    progress: true,
    history: true,
    center: true,

    transition: 'slide', // none/fade/slide/convex/concave/zoom

    // More info https://github.com/hakimel/reveal.js#dependencies
    dependencies: [
      {
        src: 'lib/js/classList.js', condition: function () {
        return !document.body.classList;
      }
      },
      {
        src: 'plugin/markdown/marked.js', condition: function () {
        return !!document.querySelector('[data-markdown]');
      }
      },
      {
        src: 'plugin/markdown/markdown.js', condition: function () {
        return !!document.querySelector('[data-markdown]');
      }
      },
      {
        src: 'plugin/highlight/highlight.js', async: true, callback: function () {
        hljs.initHighlightingOnLoad();
      }
      },
      {src: 'plugin/zoom-js/zoom.js', async: true},
      {src: 'plugin/notes/notes.js', async: true}
    ]
  });

</script>

</body>
</html>
